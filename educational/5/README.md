<div dir="rtl">
 
# C - Dragons

سوال میگه که یه نفر به اسم Kirito داره یه بازی انجام میده که توش باید با تعدادی اژدها بجنگه. هر اژدها یک عدد به عنوان قدرتش و یک عدد دیگه به عنوان جایزه داره. Kirito یک عدد `s` به عنوان قدرت اولیه داره و با همه اژدهاها (به ترتیب) دوئل می‌کنه. اگر قدرت Kirito از قدرت اژدهاهه بیشتر باشه، اون رو شکست میده و جایزه اون اژدها رو میگیره و به قدرتش اضافه می‌کنه و میره سراغ اژدهای بعدی. اگر هم قدرتش از قدرت اژدهاهه بیشتر نباشه، شکست می‌خوره و می‌میره.

Kirito می‌تونه با هر ترتیبی که بخواد با اژدهاها دوئل کنه. باید بفهمیم که آیا ترتیبی از اژدهاها وجود داره که Kirito بتونه پیروز بشه؟

### راه حل اول (که Time Limit می‌خوره)

می‌تونیم همه ترتیب‌های ممکن از اژدهاها رو امتحان کنیم و اگر به ترتیبی برخورد کردیم که همه اژدهاها شکست می‌خوردند، YES چاپ کنیم و اگر هیچ‌کدوم از ترتیب‌ها جواب نداد، NO.

مشکل این راه‌حل اینه که امتحان کردن همه ترتیب‌ها زمان‌بره. چون تعداد ترتیب‌ها، فاکتوریل تعداد اژدهاهاست (<code dir="ltr">n!</code>). چون `n` میتونه به بزرگی 1000 باشه، <code dir="ltr">n!</code> میتونه به بزرگی <code dir="ltr">4 * 10^2567</code> باشه. (همونطوری که می‌دونیم) تعداد عملیاتی که کامپیوتر می‌تونه توی یه ثانیه انجام بده حدود <code dir="ltr">10 ^ 8</code> هست و بررسی همه ترتیب‌ها سال‌ها طول می‌کشه. پس این راه‌حل از مرتبه <code dir="ltr">O(n!)</code> ه.

بررسی همه راه‌حل ها بدون اینکه ترتیب خاصی براشون در نظر بگیریم، Brute Force یا Complete Search نام داره.

### راه حل دوم (که Accept می‌شه)

Kirito فقط میتونه اژدهاهایی رو شکست بده که قدرت اون اژدها از قدرت Kirito کمتر باشه. پس دوئل با یه اژدهای قوی‌تر، کار بیهوده‌ایست چون که Kirito می‌میره و بازی تموم می‌شه! پس باید اول با اژدهاهای ضعیف‌تر دوئل کرد، شکستشون داد و به قدرت Kirito اضافه کرد به این امید که قدرت اونقدری اضافه بشه که بتونه اژدهاهایی که در حال حاضر نمی‌تونه شکست بده رو در آینده شکست بده.

وقتی Kirito با یه اژدهایی که می‌تونه شکستش بده دوئل میکنه، صرف‌نظر از این‌که جایزه اژدها و قدرتش چقدره، نه نتها چیزی از دست نمی‌ده، بلکه قدرتش افزایش پیدا می‌کنه. پس اهمیتی نداره که اول با کدوم اژدهای ضعیف دوئل کنه. پس هردفعه یکی از اژدهاهایی که می‌شه شکستش داد رو انتخاب می‌کنیم، شکستش میدیم و جایزه‌ش رو به قدرتمون اضافه می‌کنیم. دوباره یکی دیگه که الآن میشه شکست داد رو برمی‌داریم، شکست می‌دیم و ... . دقت کنید که توی هر مرحله، حریصانه یکی از اژدهاها رو شکست میدیم و دیگه کارمون با این اژدها تموم می‌شه (یعنی در ادامه الگوریتم، دیگه کاری به این اژدها نداریم).

توی پیاده‌سازی، یکی از راه‌ها اینه که اژدهاها رو بر اساس قدرتشون از ضعیف به قوی مرتب کنیم و با همین ترتیب باهاشون بجنگیم. اگر در میانه دوئل‌ها به اژدهایی برخورد کردیم که نمی‌تونستیم شکست بدیم، بازی رو می‌بازیم. چون نه اژدهایی دیگه هست که ضعیف‌تر باشه که بریم شکستش بدیم و قوی‌تر بشیم و برگردیم با این اژدها دوباره دوئل کنیم و نه سایر اژدهاهای باقی‌مونده رو می‌تونیم شکست بدیم چون از این اژدهایی که باهاش مواجهیم قوی‌ترن. اگر همه رو تونستیم شکست بدیم، بازی رو بردیم. این پیاده سازی از مرتبه <code dir="ltr">O(nlogn)</code> ه. چون باید اژدهاها رو `sort` کنیم.

# D - Gravity Flip

تعدادی جعبه داریم که در چند ستون، روی همدیگه چیده شده‌اند. سوال می‌خواد بدونه که اگر جاذبه به جای این‌که به سمت پایین باشه، یکمرتبه تغییر سو بده و به سمت راست بشه، ستون‌ها چه شکلی میشن (به شکل سوال نگاه کنید تا بهتر متوجه بشید).

### راه حل اول (که Accept می‌شه)

تعداد ستون‌ها قبل از تغییر سمت جاذبه، حداکثر ۱۰۰ تا و ارتفاع هر ستون هم حداکثر ۱۰۰ هست. پس اگر جاذبه تغییر کنه، باز هم تعداد ستون‌ها همون ۱۰۰ تا و ارتفاع هر ستون هم ۱۰۰ باقی می‌مونن. در حقیقت با یه جدول با اندازه ۱۰۰ در ۱۰۰ مواجهیم که می‌خواهیم همه عناصرش رو هل بدیم به سمت راست.

میشه همین رو شبیه‌سازی کرد. یعنی تغییر جاذبه رو مرحله به مرحله افتادن جعبه‌ها به سمت راست، شبیه‌سازی کنیم. هر جعبه‌ای که سمت راستش خالی بود، انقدر به سمت راست شیفت پیدا میکنه تا دیگه سمت راستش خالی نباشه.

توی پیاده‌سازی میشه این کار رو توی <code dir="ltr">O(n^3)</code> (یا اگه بهتر کد بزنیم توی <code dir="ltr">O(n^2)</code>) انجام داد.

### راه حل دوم (که Accept می‌شه)

اگر بیشتر به Sample Test ها دقت کنیم، می‌بینیم که جواب، همون ورودیه فقط مرتب شدن. مثلا اگر ورودی <code dir="ltr">3 2 1 2</code> هست، پاسخ <code dir="ltr">1 2 2 3</code> هستش. این شهود، در واقع درست هم هست. ستون‌ها بعد از تغییر جاذبه به صورت صعودی مرتب میشن، زیرا اگر اینطور قرار نگیرن، حتما جعبه‌ای در محلی که ستون‌ها صعودی بودنشون رو از دست می‌دن قرار داره که به سمت راست میفته. برای اینکه بهتر متوجه بشید، همون مثال <code dir="ltr">3 2 1 2</code> رو در نظر بگیرید. فرض کنید جواب، <code dir="ltr">1 2 2 3</code> نباشه و مثلا بخواهد که <code dir="ltr">1 3 2 2</code> باشه. این جواب درست نیست چون که ستونی که 3 جعبه داره، بالاترین جعبه‌ش به سمت راست میفته چون سمت راستش جعبه‌ای نیست که نگهش داره. این جعبه ۲ ستون به سمت راست سرازیر میشه تا به آخرین ستون سمت راست برسه و اونجا متوقف بشه. در این حالت به <code dir="ltr">1 2 2 3</code> رسیدیم؛ همون جوابی که از قبل داشتیم.

پس تنها کاری که می‌کنیم اینه که ورودی رو می‌گیریم، مرتبش میکنیم و به عنوان خروجی چاپ می‌کنیم. این راه‌حل از مرتبه <code dir="ltr">O(nlogn)</code> ه چون `sort` میکنیم.

</div>
