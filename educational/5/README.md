<div dir="rtl">

A - System of Equations
===
با توجه به معادلات داده شده، میدانیم که n  و m را سوال به ما میدهد، پس اگر  a یا b را داشته باشیم میتوانیم دیگر مجهول را بدست آوریم و چک کنیم که آیا در معادله ی دیگر هم صدق میکند یا نه.

مثلا معادله ی اول یعنی:
<div dir='ltr'>

```
a ^ 2 + b = n
```
</div>

را در نظر میگیریم و به ازای همه ی مقادیری که a میتواند اختیار کند، یعنی مقادیری که شرط `a ^ 2 < n` در آن برقرار باشد،  b را از معادله ی یاد شده پیدا میکنیم. حال a و b  را داریم و کافیست برسی کنیم که آیا این مقادیر a و b در معادله ی دوم هم صدق میکند یا نه. اگر صرق کند یعنی به یک جواب رسیده ایم و جواب خود را یکی زیاد میکنیم.


<div dir="ltr">

```
for all values of 'a':
	calculate 'b' from first equation.
    if 'a' and 'b' satisfy the second equation.
    ans += 1
print ans
```

</div>

با توجه به اینکه n میتواند تنها `1000` باشد پس در بدترین حالت حالات بسیار کمی وجود دارد که باید در for  برسی کنیم، پس راه حل شدنیست.

B - Below the Diagonal 
===
سوال میگه که یک ماتریس `n * n` میدم بهتون که n - 1 یک توی این ماتریس هست و بقیه ی المانهای آن صفر هست.
چیزی که میخاد اینه که اون  `n - 1` یک را با اون دو کاری که مجاز به انجامش هستیم، یعنی جابه جایی سطر ها و ستون ها به زیر قطر اصلی ماتریس ببریم.

راه حل 
---
راه حلی که قصد گفتنش را دارم توی  n  مرحله ماتریس را به حالتی که سوال درخواست کرده تبدیل میکنه. به اینصورت که از ستون آخر شروع میکنیم و تمام المان های آن ستون را که روی قطر اصلی هستند و یا بالای آن هستند را با روشی که در ادامه گفته میشه از یک ها خالی میکنه و بعد از آن مثلا اگر فرض کنیم که در مرحله ی دوم از n مرحله ی ذکر شده باشیم سعی میکنیم که سطر دوم از پایین ( n - 1 امین سطر) را فیکس کنیم در مراحل بعدی اصلا کاری باهاش نداشته باشیم.
اگر برای همه ی n ستون از این مطمین شویم که بالا و یا روی قطر اصلی یکی وجود ندارد به خواسته ی خود رسیده ایم، این همین کاریست که در این الگوریتم انجام میدهیم.

حالا سوال اینجاست که دو مورد ذکر شده را چگونه انجام دهیم.

برای مورد اول، یعنی خالی کردن المان های بالا و روی قطر ستون ها میتوانیم با برسی همه ی ستون ها، ستونی را پیدا کنیم که آن المان هایی که مورد نظرمان هست فقط حاوی صفر باشند، چون تنها 	 n - 1 یک داریم ولی n ستون داریم، پس چنین ستونی قطعا وجود خواهد داشت،‌ با پیدا کردن چنین ستونی میتوانیم آنرا با ستون مورد نظرمان جا به جا کنیم و مطمین شویم کا در آن ستون هیچ المان یکی روی قطر اصلی یا بالای آن نیست. با توجه به اینکه این ستون را دیگر تغییر نمیدهیم، اگر برای همه ی ستون ها چنین کاری انجام دهیم مطمین هستیم که به چیزی که سوال خواسته رسیده ایم.

برای مورد دوم، یعنی فیکس کردن سطر، کافیست سطری را از بالای ماتریس پیدا کنیم که حاوی یک باشد و آنرا با سطر مورد نظرمان جا به جا کنیم. بعد از فیکس کردن این سطر دیگر نباید یک های آنرا در نظر بگیریم، زیرا میتوان فرض کرد که آنها مصرف شده اند و دیگر نیازی به در نظر گرفتن آنها نداریم.

میتوان به این راه حل اینگونه هم نگاه کرد که ما با حذف سطر و ستون آخر ماتریس و مطین شدن از اینکه حداقل یکی از یک ها را مصرف کرده ایم(با فیکس کردن سطر) حال به جای ماتریس `n * n`  و `n - 1`   یک در آن، یک ماتریس `(n - 1) * (n - 1)` با `n - 2`  یک داریم مانند قبل اقدام به حل آن میکنیم.

با n بار انجام دادن این مراحل به جواب میرسیم :)


برای دیدن جزییات اینکه چگونه ستون خالی را تشخیص دهیم و یا چگونه سطر را فیکس کنیم و یک های آنرا حذف کنیم، حتما کد و کامنت های آنرا بخونید.
 
# C - Dragons

سوال میگه که یه نفر به اسم Kirito داره یه بازی انجام میده که توش باید با تعدادی اژدها بجنگه. هر اژدها یک عدد به عنوان قدرتش و یک عدد دیگه به عنوان جایزه داره. Kirito یک عدد `s` به عنوان قدرت اولیه داره و با همه اژدهاها (به ترتیب) دوئل می‌کنه. اگر قدرت Kirito از قدرت اژدهاهه بیشتر باشه، اون رو شکست میده و جایزه اون اژدها رو میگیره و به قدرتش اضافه می‌کنه و میره سراغ اژدهای بعدی. اگر هم قدرتش از قدرت اژدهاهه بیشتر نباشه، شکست می‌خوره و می‌میره.

Kirito می‌تونه با هر ترتیبی که بخواد با اژدهاها دوئل کنه. باید بفهمیم که آیا ترتیبی از اژدهاها وجود داره که Kirito بتونه پیروز بشه؟

### راه حل اول (که Time Limit می‌خوره)

می‌تونیم همه ترتیب‌های ممکن از اژدهاها رو امتحان کنیم و اگر به ترتیبی برخورد کردیم که همه اژدهاها شکست می‌خوردند، YES چاپ کنیم و اگر هیچ‌کدوم از ترتیب‌ها جواب نداد، NO.

مشکل این راه‌حل اینه که امتحان کردن همه ترتیب‌ها زمان‌بره. چون تعداد ترتیب‌ها، فاکتوریل تعداد اژدهاهاست (<code dir="ltr">n!</code>). چون `n` میتونه به بزرگی 1000 باشه، <code dir="ltr">n!</code> میتونه به بزرگی <code dir="ltr">4 * 10^2567</code> باشه. (همونطوری که می‌دونیم) تعداد عملیاتی که کامپیوتر می‌تونه توی یه ثانیه انجام بده حدود <code dir="ltr">10 ^ 8</code> هست و بررسی همه ترتیب‌ها سال‌ها طول می‌کشه. پس این راه‌حل از مرتبه <code dir="ltr">O(n!)</code> ه.

بررسی همه راه‌حل ها بدون اینکه ترتیب خاصی براشون در نظر بگیریم، Brute Force یا Complete Search نام داره.

### راه حل دوم (که Accept می‌شه)

Kirito فقط میتونه اژدهاهایی رو شکست بده که قدرت اون اژدها از قدرت Kirito کمتر باشه. پس دوئل با یه اژدهای قوی‌تر، کار بیهوده‌ایست چون که Kirito می‌میره و بازی تموم می‌شه! پس باید اول با اژدهاهای ضعیف‌تر دوئل کرد، شکستشون داد و به قدرت Kirito اضافه کرد به این امید که قدرت اونقدری اضافه بشه که بتونه اژدهاهایی که در حال حاضر نمی‌تونه شکست بده رو در آینده شکست بده.

وقتی Kirito با یه اژدهایی که می‌تونه شکستش بده دوئل میکنه، صرف‌نظر از این‌که جایزه اژدها و قدرتش چقدره، نه نتها چیزی از دست نمی‌ده، بلکه قدرتش افزایش پیدا می‌کنه. پس اهمیتی نداره که اول با کدوم اژدهای ضعیف دوئل کنه. پس هردفعه یکی از اژدهاهایی که می‌شه شکستش داد رو انتخاب می‌کنیم، شکستش میدیم و جایزه‌ش رو به قدرتمون اضافه می‌کنیم. دوباره یکی دیگه که الآن میشه شکست داد رو برمی‌داریم، شکست می‌دیم و ... . دقت کنید که توی هر مرحله، حریصانه یکی از اژدهاها رو شکست میدیم و دیگه کارمون با این اژدها تموم می‌شه (یعنی در ادامه الگوریتم، دیگه کاری به این اژدها نداریم).

توی پیاده‌سازی، یکی از راه‌ها اینه که اژدهاها رو بر اساس قدرتشون از ضعیف به قوی مرتب کنیم و با همین ترتیب باهاشون بجنگیم. اگر در میانه دوئل‌ها به اژدهایی برخورد کردیم که نمی‌تونستیم شکست بدیم، بازی رو می‌بازیم. چون نه اژدهایی دیگه هست که ضعیف‌تر باشه که بریم شکستش بدیم و قوی‌تر بشیم و برگردیم با این اژدها دوباره دوئل کنیم و نه سایر اژدهاهای باقی‌مونده رو می‌تونیم شکست بدیم چون از این اژدهایی که باهاش مواجهیم قوی‌ترن. اگر همه رو تونستیم شکست بدیم، بازی رو بردیم. این پیاده سازی از مرتبه <code dir="ltr">O(nlogn)</code> ه. چون باید اژدهاها رو `sort` کنیم.

# D - Gravity Flip

تعدادی جعبه داریم که در چند ستون، روی همدیگه چیده شده‌اند. سوال می‌خواد بدونه که اگر جاذبه به جای این‌که به سمت پایین باشه، یکمرتبه تغییر سو بده و به سمت راست بشه، ستون‌ها چه شکلی میشن (به شکل سوال نگاه کنید تا بهتر متوجه بشید).

### راه حل اول (که Accept می‌شه)

تعداد ستون‌ها قبل از تغییر سمت جاذبه، حداکثر ۱۰۰ تا و ارتفاع هر ستون هم حداکثر ۱۰۰ هست. پس اگر جاذبه تغییر کنه، باز هم تعداد ستون‌ها همون ۱۰۰ تا و ارتفاع هر ستون هم ۱۰۰ باقی می‌مونن. در حقیقت با یه جدول با اندازه ۱۰۰ در ۱۰۰ مواجهیم که می‌خواهیم همه عناصرش رو هل بدیم به سمت راست.

میشه همین رو شبیه‌سازی کرد. یعنی تغییر جاذبه رو مرحله به مرحله افتادن جعبه‌ها به سمت راست، شبیه‌سازی کنیم. هر جعبه‌ای که سمت راستش خالی بود، انقدر به سمت راست شیفت پیدا میکنه تا دیگه سمت راستش خالی نباشه.

توی پیاده‌سازی میشه این کار رو توی <code dir="ltr">O(n^3)</code> (یا اگه بهتر کد بزنیم توی <code dir="ltr">O(n^2)</code>) انجام داد.

### راه حل دوم (که Accept می‌شه)

اگر بیشتر به Sample Test ها دقت کنیم، می‌بینیم که جواب، همون ورودیه فقط مرتب شدن. مثلا اگر ورودی <code dir="ltr">3 2 1 2</code> هست، پاسخ <code dir="ltr">1 2 2 3</code> هستش. این شهود، در واقع درست هم هست. ستون‌ها بعد از تغییر جاذبه به صورت صعودی مرتب میشن، زیرا اگر اینطور قرار نگیرن، حتما جعبه‌ای در محلی که ستون‌ها صعودی بودنشون رو از دست می‌دن قرار داره که به سمت راست میفته. برای اینکه بهتر متوجه بشید، همون مثال <code dir="ltr">3 2 1 2</code> رو در نظر بگیرید. فرض کنید جواب، <code dir="ltr">1 2 2 3</code> نباشه و مثلا بخواهد که <code dir="ltr">1 3 2 2</code> باشه. این جواب درست نیست چون که ستونی که 3 جعبه داره، بالاترین جعبه‌ش به سمت راست میفته چون سمت راستش جعبه‌ای نیست که نگهش داره. این جعبه ۲ ستون به سمت راست سرازیر میشه تا به آخرین ستون سمت راست برسه و اونجا متوقف بشه. در این حالت به <code dir="ltr">1 2 2 3</code> رسیدیم؛ همون جوابی که از قبل داشتیم.

پس تنها کاری که می‌کنیم اینه که ورودی رو می‌گیریم، مرتبش میکنیم و به عنوان خروجی چاپ می‌کنیم. این راه‌حل از مرتبه <code dir="ltr">O(nlogn)</code> ه چون `sort` میکنیم.

# E - Registration system 

سوال درباره‌ی یک سیستم ارائه دهنده‌ی ایمیل هست. هر کاربر برای ثبت نام، یک نام کاربری به سایت می‌دهد و اگر این نام در سیستم ثبت نشده باشد سیستم پیام OK می‌دهد و کاربر با موفقیت ثبت نام می‌شود. اما اگر نام درخواستی کاربر در سیستم موجود بود، سیستم یک نام جدید بر اساس آن می‌سازد و آن را ثبت می‌کند.  
نام جدید، همان نام اصلی است که در آخر آن یک عدد اضافه شده است. این عدد از ۱ شروع می‌شود، اگر این نام  کاربری هم ثبت شده بود سیستم به سراغ عدد بعدی می‌رود و این کار را تا زمانی ادامه می‌دهد که نام ساخته شده در سیستم موجود نباشد، سپس این نام را برای کاربر ثبت می‌کند.  

### راه حل

برای ثبت وضعیت نام های کاربری ثبت شده در سیستم، از یک <code dir="ltr">map<string, int></code> استفاده می‌کنیم.  
هر نام کاربری ای که ثبت شد، مقدار متناظر آن را در `map` یک واحد تغییر می‌دهیم.  
این طوری در هر مرحله می‌دانیم که چه عددی را باید به نام کاربری اضافه کنیم.  


# F - Watchmen

در این سوال با دو نوع فاصله‌ی بین نقاط سروکار داریم.  
همان طور که می‌دانیم، فاصله‌ی عادی ای که بین دو نقطه در نظر می‌گیریم از رابطه‌ی زیر محاسبه می‌شود.  

![regular distance](https://odzkskevi.qnssl.com/c435140196e2121035c1541a3aa2fb10?v=1502882776)

نوع دیگری از فاصله به نام فاصله‌ی منهتن بین نقاط تعریف می‌شود که به صورت زیر قابل محاسبه است:  

<div dir="ltr">

```
|xi - xj| + |yi - yj|
```

</div>

سوال این است که اگر تعدادی نقطه داشته باشیم، به ازای چند جفت از آنها، هر دو فاصله برابر می‌شود.  

با کمی دقت متوجه می‌شویم که شرط لازم و کافی برای این که فاطه‌ها برابر بشوند این است که دو نقطه در حداقل یکی از محور‌های x یا y در یک راستا قرار داشته باشند.  
به بیانی دیگر، یا y های دو نقطه برابر باشند و یا x های آنها (یا هر دو).  

### راه حل

برای هر یک از محور ها یک map در نظر می‌گیریم و با آن، تعداد تکرار یک عدد به عنوان مختصه در آن محور را ذخیره می‌کنیم.  
فرض کنید از بین نقاط داده شده، ۳ تای آن‌ها دارای مختصه‌ی x برابر باشند. می‌توان نتیجه گرفت که ۳ جفت نقطه وجود دارند که فاصله‌ی معمولی و فاصله ی منهتن بین آنها یکسان است.  
به طرو کلی تر، اگر `n` نقطه دارای مختصه‌ی یکسان باشند، <code dir="ltr">(n * (n-1)) / 2</code> جفت نقطه با فواصل معمولی و منهتن برابر خواهیم داشت.  

تنها نکته ای که باید در نظر بگیریم این است که ممکن است ۲ نقطه، دقیقا در مختصات یکسان واقع شده باشند، در این صورت ما یک‌بار در محور y و یک بار در محور x این جفت نقطه را شمرده ایم. پس باید به ازای این نقاط، یکی از جواب به دست آمده کم کنیم.  

به طور مشابه می‌توان با استفاده از map، تعداد نقطه‌ها با مختصات مشابه را شمارش کرد و از جواب نهایی کم کرد.  
  
 برای اینکه راه حل را دقیق تر متوجه شوید، کد پاسخ صحیح این سوال را مطالعه کنید.  

در ضمن  مراقب عدد‌های بزرگ باشید و از `long long` استفاده کنید!

</div>

