<div dir='rtl'>

# 725 Division 
 
## راه حل اول -->‌ Time Limit Exceeded 
از کوچکترین عدد نه رقمی تا بزرگترین عدد ده رقمی را در یک for برسی میکنیم. پنج رقم اول و دوم عدد را جدا میکنیم و برسی میکنیم که همه ی اعداد 0 تا ۹ را پوشش دهد. 
کوچکترین عدد نه رقمی بدون تکرار 012345678 است و بزرگتری عدد ۱۰ رقمی بدون تکرار 9876543210. 
یعنی در این راه حل حداقل باید 9864197532 (تعداد بار اجرای for) مقدار عملیات انجام شود، یعنی تقریبا 10^10 عملیات. که برای رد کردن تایم لیمیت بسیار زیاد است. 

 
## راه دوم --‌>‌ Accepted 
با کمی برسی سوال به این نتیجه میرسیم که نیازی نیست همه ی اعداد ممکن ۹ تا ۱۰ رقمی را برسی کنیم. 
با توجه به فورمول سوال abcde / fghij = N اگر صورت و یا مخرج را داشته باشیم میتوانیم دیگر مجهول را بدست آوریم. 
مثلا برای تست کیس دوم سوال که N = 62 است اگر 1283را به عنوال صورت کسر به نحوی بدست آوریم، کافیست N * 1283 را بدست آوریم تا مخرج یعنی 79546 بدست آید. (یعنی صورت از اینکه مخرجچیست، بدست می آید و نیازی نیست جداگانه حساب شود.) 
حال کافیست به ازای همه ی مقادیر ممکنی که مخرج(و یا صورت) میتواند داشته باشد، با استفاده از فورمول صورترا بدست آوریم سپس برسی کنیم که این دو عدد همه ی مقادیر 0 تا 9 را پوشش دهد. 
با توجه به اینکه پر ارزش ترین عدد مخرج یعنی f میتواند 0 باشد، باید از کوچکترین عدد چهار رقمی ممکن تا بزرگترین عدد ۵ رقمی ممکن را در یک for برسی کنیم. 
کوچکترین عدد چهار رقمی بدون تکرار 1234 است و بزرگتری عدد پنج رقمی بدون تکرار 98765. تعداد اعداد ممکن که برسی میشوند 97522 ( ۱۲۳۴ - ۹۸۷۶۵) است که مناسب است. 
برای چک کردن اینکه آیا صورت و مخرج به دست آمده همه ی اعداد صفر تا نه را پوشش میدهد یا نه کافیست یک آرایه ی ۱۰ تایی که ابتدا خانه های آن صفر هست را در نظر بگیریم و به ازای digit اخر عدد، خانه ی متناظر آن digit در آرایه را ۱ کنیم سپس عدد را بر ۱۰ تقسیم کنیم. این عمل را تا زمانی که عدد صفر نشده انجام میدهیم. 
توجه شود که اگر یکی از اعداد ما (صورت یا مخرج) چهار رقمی بود یعنی عدد صفر پوشش داده شده است. 
حال اگر همه ی خانه های آرایه ۱ بود یعنی اعداد ۰ تا ۹ پوشش داده شده اند و دو عدد ما یک جواب است. 
برای اینکه بفهمیم ایا جوابی وجود داشته یا نه، اگر حتی یک جواب به دست آمد یک بولین را true میکنیم. در نهایت اگر آن بولین false بود There are no solutions for n چاپ میکنیم. 
برای چاپ کردن اعداد، با توجه به اینکه اعداد ممکن است چهار رقمی باشند ولی ما باید پنج رقمی چاپ کنیم(مثل تست کیس های خود سوال)، راه مناست این است که با توجه به روشی که برای پرینت کردن داریم مثلا printf یا cout، عملگر های مناست آنها برای چنین اعمال را استفاده کنیم. به کد پیوست شده توجه کنید. 
نکته ی مهم: در خروجی سوال ذکر شده که تست کیس ها باید با خط خالی از هم جدا شوند. وقتی سوال میگوید جدا شود یعنی فقط بین تست کیس ها باید خط خالی باشد و نه در آخر هر تست کیس. یک راه برای انجام این کار این است که اول هر تست کیس به جر تست کیس اول یک خط جدید چاپ شود. در کد پیوست شده این کار انجام شده است. 
 
 
 
 
 
# 11078 Open Credit System 
## راه حل اول --> Time Limit Exceeded 
ساده ترین راه که ابتدا به ذهن میرسد این است که دو به دوی اعداد داده شده در سوال را در دو for در نظر گرفته و بین فاصله ی این اعداد از همدیگر max بگیریم. این راه حل تقریبا n ^ 2 عملیات نیاز دارد که یعنی 
10 ^ 10 عملیات که منجلب به تایم میشود. 
 
## راه حل دوم --> Accepted 
با برسی عمیق تر سوال به این نتیجه میرسیم که به ازای یک عدد در جایگاه i ام نیازی نیست که همه ی اعداد بالای آن چک شود و اگر بدانیم ماکسیمم عددی که بالای آن وجود دارد چیست نیز کافیست زیرا اگر عددی بالای i وجود داشته باشد مثلا k، آنگاه اگر k ماکسیمم عدد ممکن بالای i باشد فاصله ی آن تا عدد در جایگاه i ام خود نیز ماکسیمم است. 
مثلا دنباله ی اعداد 38 31 3 9 44 7 87 را از چپ با راست در نظر بگیرید. 
به طور مثال وقتی در حال برسی عدد 31 هستیم به جای اینکه همه ی اعداد بالای ان یعنی 87 7 44 9 3 را برسی کنیم و ماکسیمم فاصله آن ها با 31 را بدست آوریم، کافیست بدانیم ماکسیمم عدد بالای 31، 87 است آنگاه ماکسیمم فاصله 31 – 87 است. 
پس راه حل به اینگونه است که در یک for از بالا به پایین هر بار یک عدد را برسی میکنیم و ماکسیمم عدد مشاهده شده تا به آنجا را نیز ذخیره میکنیم تا از رابطه ای که بالا گفته شد استفاده کنیم و نیاز نداشته باشیم که در یک for دیگر همه ی اعداد بالای آن را برسی کنیم. با برسی همه ی اعداد در این for و ماکسیمم گرفتن بین همه ی آنها به جواب سوال رسیده ایم. 
 

# 11059 Maximum Product
## راه اول --> Accepted
با توجه به اینکه n ماکسیمم ۱۸ است، میتوان الگوریتم ساده ای برای سوال طراحی کرد که n ^ 3 عملیات انجام میدهد.
میتوان به ازای هر i و j روی اعداد همه ی اعداد در بازه ی [i, j] را ضرب کرد، سپس بین همه ی این موارد ماکسیمم گرفت، که این همان جواب سوال است.
نکته: با توجه به اینکه n میتواند ۱۸ باشد و هر عدد نیز میتواند ماکسیمم ۱۰ باشد، پس ماکسیمم ضرب ممکنی که میتوانیم داشته باشیم 18 ^ 10 است که نمیتواند در int ذخیره شود. پس باید در long long ذخیره شود.
نکته: بعد از هر تست کیس باید یک خط خالی چاپ شود. برعکس سوال ۷۲۵ که بین هر تست کیس باید خط خالی چاپ میشد.
 

# 12406 - Help Dexter

## راه حل اول --> Accepted
اولین راه حلی که به ان فکر میکنیم، brute force است، آیا میتوان همه ی اعداد ممکن که از ۱ و ۲ ساخته شده اند و ماکسیمم ۱۷ رقم هستند را برسی کرد ؟ بله :)
برای ماکسیمم رقم که ۱۷ است، اگر ۱۷ جایگاه در نظر بگیریم، در هر جایگاه میتوانیم ۱ قرار دهیم یا ۲ قرار دهیم، پس 17 ^ 2 حالت وجود دارد که تقریبا ۱۳۰۰۰۰ حالت متفاوت است که عدد کوچکیست.
حال سوال این است که چگونه همه ی این حالات را به صورت بهینه بسازیم و برسی کنیم ؟
میدانیم که عملیات های bitwise (مانند شیفت دادن) بسیار سریع هستند، پس سعی میکنیم از بیت های یک int برای نشان دادن حالات متفاوت استفاده کنیم.
به اینصورت که اگر مثلا در جایگاه iام بیت 0 وجود داشت ما فرض میکنیم که در جایگاه iام از عدد اصلی عدد 1 قرار دارد، و اگر بیت 1 وجود داشت فرض میکنیم که عدد 2 در عدد اصلی وجود دارد.
با توجه به اینکه دنبال اعداد b رقمی میگردیم فقط به b بیت اول int نیاز داریم.
برای دیدن جزییات بیشتر راجع به برسی کردن همه ی حالات با استفاده از بیت های یک int پیشنهاد میشود کد پیوست شده را حتما برسی کنید.
نکته: با توجه به اینکه حالاتی که برسی میکنیم باید بر ۲ به توان q بخش پذیر باشند میتوان فضای حالت (همه ی حالات ممکنی که وجود دارد) را کوچکتر کرد و اصطلاحا فضای حالت را هرس کرد، که البته با توجه به حالات نسبتا کم این سوال نیاز نیست.



# 296 Safebreaker

## راه حل اول -->‌ Accepted
باز هم ابتدا به راه حل brute force فکر میکنیم. آیا میتوان همه ی حالات ممکن کد مخفی را برسی کنیم و ببینیم که آیا همه ی m حدس سوال منطبق بر ان هستند یا خیر ؟
با توجه به اینکه کد مخفی از 0000 تا 9999 میتواند باشد پس حداکثر باید 9999 حالت متفاوت را برسی کنیم، که تعداد کمی است، پس برسی همه ی حالات مقدور است.
در یک for میتوان همه ی حالات کد مخفی را از 0000 تا 9999 برسی کرد. و به ازای هر کدام از آنها چک کرد که آیا حدس هایی که سوال به ما داده است بر آن منطبق هستند یا نه.
برای چک کردن اینکه آیا کد مخفی فعلی که در حال برسی آن هستیم با یک حدس مطابقت دارد یا خیر، ابتدا جایگاه هایی که در حدس و کد مخفی برابر هستند را مشماریم و آنها را مارک میکنیم تا در شمردن عدد های درستی که در جایگاه نادرست هستند تاثیر نگذارند.
سپس به ازای جایگاه هایی از حدس که در مرحله اول مارک نشده اند، برسی میکنیم که آیا عددی مشابه با آن در کد مخفی وجود دارد یا خیر، همه ی این ها را هم میشماریم و مثل مرحله اول مارک میکنیم که تکراری شمرده نشوند.
اگر همه ی حدس ها با کد مخفی مطابقت داشت، کد مخفی که در حال برسی آن بودیم یک جواب است.
جزییات بیشتر در کد پیوست شده قابل مشاهده است.

# E - Jury Marks
## راه حل اول --> Accepted
میدانیم n تعداد از score هایی که توسط داور ها اعلام میشود را داریم میشود.
امتیاز اول(به طور مثال) از امتیاز هایی را که میدانیم را دی نظر میگیریم، این امتیاز بلاخره در یک زمانی اعلام شده است.
حال اگر همه ی زمان هایی که این امتیاز میتوانسته اعلام شود را امتحان کنیم و چک کنیم که با آن شرایط n - 1 امتیاز دیگر هم اعلام میشود یا نه میتوان همه ی حالات امتیاز اولیه را بدست آورد.
به طور مثال
2 2
-2000 -2000
3998000 4000000
را در نظر بگیرید. امتیاز 4000000 است، همه ی زمان هایی که این امتیاز میتوانسته اعلام شود را یکی یکی در امتحان میکنیم و چک میکنیم که دیگر امتیاز یعنی ۳۹۹۸۰۰۰ اعلام میشود یا نه. اگر اعلام شود پس به یک حالت درست رسیده ایم.
این امتیاز در دو زمان میتوانسته اعلام شود، بعد از اینکه داور اول نمره ی منفی ۲۰۰۰ را داد یا بعد از اینکه داور دوم امتیاز منفی ۲۰۰۰ را داد.
در حالت اول امتیاز اولیه 4002000 بوده است که بعد از نمره ی داور اول به 4000000 تبدیل شده است و بعد از امتیاز داور دوم به 3998000 تبدیل شده است، پس همه ی امتیاز ها اعلام شدند و به یک جواب درست رسیدیم.
در حالت دوم، امتیاز اولیه 4004000 بوده است که بعد از امتیاز داور اول و دوم به 4000000 رسیده است، در این حالت امتیاز دیگر اعلام نشد پس این حالت درست نیست.
پس جوال این تست کیس ۱ است.
برای چک کردن وجود امتیازی که در حال حاضر بدست آورده ایم در بین امتیاز های اعلام شده در سوال و ذخیره کردن آن به منظور اینکه امتیاز های اعلام شده تکراری را دوباره به حساب نیاوریم میتوانیم از set استفاده کنیم.
جزییات بیشتر را در کد پیوست شده مشاهده کنید.



</div>
